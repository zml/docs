<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <!-- <meta name="description" content="Zine: Fast, Scalable and Flexible Static Site Generator"> -->
    <!-- <meta name="twitter:card" content="summary"> -->
    <!-- <meta name="twitter:site" content="@zml.ai"> -->
    <!-- <meta name="twitter:author" content="@zml.ai"> -->
    <!-- <meta name="twitter:description" content="Zine: Fast, Scalable and Flexible Static Site Generator"> -->
    <!-- <meta name="twitter:title" content="$page.title.suffix(' | ZML')"> -->
    <meta property="og:title" content="Writing your first model">
    <meta property="og:type" content="website">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Writing your first model
      - ZML
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link rel="icon" href="/zml.no_light.svg">
    
  </head>
  <body>
    <a id="logo" href="/"></a>
    <nav id="menu">
      <a href="/">Home</a>
      •
      <a href="/tutorials/getting_started/">Quickstart</a>
      •
      <a href="/tutorials/write_first_model/">First Steps</a>
      <!-- • -->
      <!-- <a href="$site.page('concepts').link()">Concepts</a> -->
      <!-- • -->
      <!-- <a href="$site.page('using_zml_in_own_projects').link()">Using it in projects</a> -->
      •
      <a href="/misc/zml_api/">API Docs</a>
      •
      <a href="https://github.com/zml/zml" target="_blank">Code</a>
      •
      <a href="https://discord.gg/6y72SN2E7H" target="_blank">Discord</a>
    </nav>
    <!-- <hr style="width:min(600px, 100vw); border-color:#0798b3; color: white; border-top:1px;"> -->
    <aside id="sidebar" class="sidebar">
        <!-- <h3>Docs</h3> -->
        <a href="/tutorials/"><h5>Tutorials</h5></a>
        <div class="linkbox">
            <div><a href="/tutorials/getting_started/">Getting Started with ZML</a></div>
        
            <div><a href="/tutorials/write_first_model/">Writing your first model</a></div>
        
            <div><a href="/tutorials/working_with_tensors/">Simplifying Dimension Handling with Tagged Tensors</a></div>
        </div>
        <a href="/howtos/"><h5>How-Tos</h5></a>
        <div class="linkbox">
            <div><a href="/howtos/huggingface_access_token/">Huggingface Token Authentication</a></div>
        
            <div><a href="/howtos/dockerize_models/">Dockerize a Model</a></div>
        
            <div><a href="/howtos/deploy_on_server/">Deploying Models on a Server</a></div>
        
            <div><a href="/howtos/howto_torch2zml/">How to port Pytorch models to ZML ?</a></div>
        
            <div><a href="/howtos/add_weights/">Adding Weights Files</a></div>
        </div>
        <a href="/tutorials/"><h5>Learn more</h5></a>
        <div class="linkbox">
            <div><a href="/learn/concepts/">ZML Concepts</a></div>
        </div>
        <a href="/tutorials/"><h5>Misc</h5></a>
        <div class="linkbox">
            <div><a href="/misc/style_guide/">ZML Style Guide</a></div>
        
            <div><a href="/misc/zml_api/">API Docs</a></div>
        </div>
    </aside>

    <main>
        <div id="content">
  <style>
    h1 {
       margin-top: 0;
     }

		#docs h2, #docs h3 {
			text-align: left;
		}

		#docs h3 {
			font-size: 1.2rem;
		}

		#docs h3::before {
      content: "##";
      font-size: 1rem;
      padding-right: 4px;
      margin-bottom: 0;
    }

    #docs h2 {
      font-size: 1.5rem;
      border-bottom: 1px dashed #aaa;
    }

    #docs h2::before {
      content: "#";
      font-size: 1rem;
      padding-right: 4px;
    }

    #docs h4 {
      font-size: 1rem;
    }

    table {
      font-size: 0.9em;
    }
    table th {
      font-size: 1em;
    }
    table td {
      white-space: nowrap;
    }
  </style>
  <h3 class="centered"></h3>
  <script>
    // Find all short <code> elements in the document, and replace them with links to our docs, or pytorch docs.
    document.addEventListener('DOMContentLoaded', function() {
      const codeElements = document.querySelectorAll('code');

      codeElements.forEach(function(codeElement) {
          const codeContent = codeElement.textContent;
          if (codeContent.includes(' ')) return;

          if (codeContent.startsWith('zml.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "/misc/zml_api/#" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          } else if (codeContent.startsWith('torch.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "https://pytorch.org/docs/stable/generated/" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          }
      });
  });
  </script>
  <!-- <h1 :text="$page.title"></h1> -->
  <div id="docs"><h1 id="writing-your-first-model">Writing your first model</h1><p><strong>In this short guide, we will do the following:</strong></p><ul><li>clone ZML to work directly within the prepared example folder</li><li>add Zig code to implement our model</li><li>add some Bazel to integrate our code with ZML</li><li>no weights files or anything external is required for this example</li></ul><p>The reason we're doing our excercise in the <code>examples</code> folder is because it's especially prepared for new ZML projects. It contains everything needed for ZML development. From <code>bazel</code> configs to <code>vscode</code> settings, and <code>neovim</code> LSP support. The <code>examples</code> folder serves as a cookiecutter ZML project example, with just a few example models added already.</p><p><strong>Note:</strong> <em>The <code>examples</code> folder is self-contained. You <strong>can</strong> make a copy of it to a location outside of the ZML repository. Simply remove all examples you don't need and use it as a template for your own projects.</em></p><p>So, let's get started, shall we?</p><p><strong>If you haven't done so already, please <a href="/tutorials/getting_started/">install bazel</a></strong>.</p><p>Check out the ZML repository. In the <code>examples</code> directory, create a new folder for your project. Let's call it <code>simple_layer</code>.</p><pre><code>git clone https://github.com/zml/zml.git
cd zml/examples
mkdir -p simple_layer
</code></pre><p>... and add a file <code>main.zig</code> to it, along with a bazel build file:</p><pre><code>touch simple_layer/main.zig
touch simple_layer/BUILD.bazel
</code></pre><p>By the way, you can access the complete source code of this walkthrough here:</p><ul><li><a href="https://github.com/zml/zml/tree/master/examples/simple_layer/main.zig" target="_blank">main.zig</a></li><li><a href="https://github.com/zml/zml/tree/master/examples/simple_layer/BUILD.bazel" target="_blank">BUILD.bazel</a></li></ul><h2 id="the-high-level-overview">The high-level Overview</h2><p>Before firing up our editor, let's quickly talk about a few basic ZML fundamentals.</p><p>In ZML, we describe a <em>Module</em>, which represents our AI model, as a Zig <code>struct</code>. That struct can contain Tensor fields that are used for computation, e.g. weights and biases. In the <em>forward</em> function of a Module, we describe the computation by calling tensor operations like <em>mul</em>, <em>add</em>, <em>dotGeneral</em>, <em>conv2D</em>, etc., or even nested Modules.</p><p>ZML creates an MLIR representation of the computation when we compile the Module. For compilation, only the <em>Shapes</em> of all tensors must be known. No actual tensor data is needed at this step. This is important for large models: we can compile them while the actual weight data is being fetched from disk.</p><p>To accomplish this, ZML uses a <em>BufferStore</em>. The <em>BufferStore</em> knows how to only load shapes and when to load actual tensor data. In our example, we will fake the <em>BufferStore</em> a bit: we won't load from disk; we'll use float arrays instead.</p><p>After compilation is done (and the <em>BufferStore</em> has finished loading weights), we can send the weights from the <em>BufferStore</em> to our computation device. That produces an <em>executable</em> module which we can call with different <em>inputs</em>.</p><p>In our example, we then copy the result from the computation device to CPU memory and print it.</p><p><strong>So the steps for us are:</strong></p><ul><li>describe the computation as ZML <em>Module</em>, using tensor operations</li><li>create a <em>BufferStore</em> that provides <em>Shapes</em> and data of weights and bias (ca. 5 lines of code).</li><li>compile the <em>Module</em> <strong>asynchronously</strong></li><li>make the compiled <em>Module</em> send the weights (and bias) to the computation device utilizing the <em>BufferStore</em>, producing an <em>executable</em> module</li><li>prepare input tensor and call the <em>executable</em> module.</li><li>get the result back to CPU memory and print it</li></ul><p>If you like to read more about the underlying concepts of the above, please see <a href="/learn/concepts/">ZML Concepts</a>.</p><h2 id="the-code">The code</h2><p>Let's start by writing some Zig code, importing ZML and often-used modules:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">zml</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;zml&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">asynk</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;async&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// shortcut to the async_ function in the asynk module</span>
<span class="type qualifier">const</span> <span class="variable">async_</span> = <span class="variable">asynk</span><span class="punctuation delimiter">.</span><span class="field">async_</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>You will use above lines probably in all ZML projects. Also, note that <strong>ZML is async</strong> and comes with its own async runtime, thanks to <a href="https://github.com/rsepassi/zigcoro" target="_blank">zigcoro</a>.</p><h3 id="defining-our-model">Defining our Model</h3><p>We will start with a very simple "Model". One that resembles a "multiply and add" operation.</p><pre><code class="zig"><span class="comment">/// Model definition
</span><span class="type qualifier">const</span> <span class="variable">Layer</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">bias</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> = <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
    <span class="field">weight</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="parameter">x</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> <span class="punctuation bracket">{</span>
        <span class="type qualifier">var</span> <span class="variable">y</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">weight</span><span class="punctuation delimiter">.</span><span class="function">mul</span><span class="punctuation bracket">(</span><span class="variable">x</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">bias</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|bias|</span> <span class="punctuation bracket">{</span>
            <span class="variable">y</span> <span class="operator">=</span> <span class="variable">y</span><span class="punctuation delimiter">.</span><span class="function">add</span><span class="punctuation bracket">(</span><span class="variable">bias</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
        <span class="keyword return">return</span> <span class="variable">y</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>You see, in ZML AI models are just structs with a forward function!</p><p>There are more things to observe:</p><ul><li>forward functions typically take Tensors as inputs, and return Tensors.<ul><li>more advanced use-cases are passing in / returning structs or tuples, like <code>struct { Tensor, Tensor }</code> as an example for a tuple of two tensors. You can see such use-cases, for example in the <a href="https://github.com/zml/zml/tree/master/examples/llama" target="_blank">Llama Model</a></li></ul></li><li>in the model, tensors may be optional. As is the case with <code>bias</code>.</li></ul><h3 id="adding-a-main---function">Adding a main() function</h3><p>ZML code is async. Hence, We need to provide an async main function. It works like this:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">_</span> <span class="operator">=</span> <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">asynk</span><span class="punctuation delimiter">.</span><span class="field">AsyncThread</span><span class="punctuation delimiter">.</span><span class="function">main</span><span class="punctuation bracket">(</span><span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">asyncMain</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>


<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">asyncMain</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="comment">// ...</span><span class="punctuation bracket"></span>
</code></pre>
<p>The above <code>main()</code> function only creates an allocator and an async main thread that executes our <code>asyncMain()</code> function by calling it with no (<code>.{}</code>) arguments.</p><p>So, let's start with the async main function:</p><pre><code class="zig"><span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">asyncMain</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="comment">// Short lived allocations</span>
    <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">_</span> <span class="operator">=</span> <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Arena allocator for BufferStore etc.</span>
    <span class="type qualifier">var</span> <span class="variable">arena_state</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="field">ArenaAllocator</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">arena_state</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">arena</span> = <span class="variable">arena_state</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Create ZML context</span>
    <span class="type qualifier">var</span> <span class="variable">context</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Context</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">context</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="type qualifier">const</span> <span class="variable">platform</span> = <span class="variable">context</span><span class="punctuation delimiter">.</span><span class="function">autoPlatform</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="error">...</span>
<span class="punctuation bracket">}</span>
</code></pre>
<p>This is boilerplate code that provides a general-purpose allocator and, for convenience, an arena allocator that we will use later. The advantage of arena allocators is that you don't need to deallocate individual allocations; you simply call <code>.deinit()</code> to deinitialize the entire arena instead!</p><p>We also initialize the ZML context <code>context</code> and get our CPU <code>platform</code> automatically.</p><h3 id="the-bufferstore">The BufferStore</h3><p>Next, we need to set up the concrete weight and bias tensors for our model. Typically, we would load them from disk. But since our example works without stored weights, we are going to create a BufferStore manually, containing <em>HostBuffers</em> (buffers on the CPU) for both the <code>weight</code> and the <code>bias</code> tensor.</p><p>A BufferStore basically contains a dictionary with string keys that match the name of the struct fields of our <code>Layer</code> struct. So, let's create this dictionary:</p><pre><code class="zig"><span class="comment">// Our weights and bias to use</span>
<span class="type qualifier">var</span> <span class="variable">weights</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">var</span> <span class="variable">bias</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">1.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">3.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">input_shape</span> = <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Shape</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="number">3</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable builtin">f16</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// We manually produce a BufferStore. You would not normally do that.</span>
<span class="comment">// A BufferStore is usually created by loading model data from a file.</span>
<span class="type qualifier">var</span> <span class="variable">buffers</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="field">BufferStore</span><span class="punctuation delimiter">.</span><span class="field">Buffers</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="variable">try</span> <span class="variable">buffers</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="string">&quot;weight&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromArray</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">weights</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="error">;
try buffers</span><span class="punctuation delimiter">.</span><span class="variable builtin">put</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="string">&quot;bias&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromArray</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">bias</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="error">;</span>

<span class="comment">// the actual BufferStore</span>
<span class="type qualifier">var</span> <span class="variable">bs</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="field">BufferStore</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
    <span class="punctuation delimiter">.</span><span class="field">arena</span> = <span class="variable">arena_state</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="field">buffers</span> = <span class="variable">buffers</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Our weights are <code>{2.0, 2.0, 2.0}</code>, and our bias is just <code>{1.0, 2.0, 3.0}</code>. The shape of the weight and bias tensors is <code>{3}</code>, and because of that, the <strong>shape of the input tensor</strong> is also going to be <code>{3}</code>!</p><p>Note that <code>zml.Shape</code> always takes the data type associated with the tensor. In our example, that is <code>f16</code>, expressed as the enum value <code>.f16</code>.</p><h3 id="compiling-our-module-for-the-accelerator">Compiling our Module for the accelerator</h3><p>We're only going to use the CPU for our simple model, but we need to compile the <code>forward()</code> function nonetheless. This compilation is usually done asynchronously. That means, we can continue doing other things while the module is compiling:</p><pre><code class="zig"><span class="comment">// A clone of our model, consisting of shapes. We only need shapes for compiling.</span>
<span class="comment">// We use the BufferStore to infer the shapes.</span>
<span class="type qualifier">const</span> <span class="variable">model_shapes</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">populateModel</span><span class="punctuation bracket">(</span><span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">bs</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// Start compiling. This uses the inferred shapes from the BufferStore.</span>
<span class="comment">// The shape of the input tensor, we have to pass in manually.</span>
<span class="type qualifier">var</span> <span class="variable">compilation</span> = <span class="operator">try</span> <span class="variable">async_</span><span class="punctuation bracket">(</span><span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">compileModel</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">model_shapes</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable builtin">forward</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">input_shape</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">platform</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="comment">// Produce a bufferized weights struct from the fake BufferStore.</span>
<span class="comment">// This is like the inferred shapes, but with actual values.</span>
<span class="comment">// We will need to send those to the computation device later.</span>
<span class="type qualifier">const</span> <span class="variable">model_weights</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">loadBuffers</span><span class="punctuation bracket">(</span><span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">bs</span><span class="punctuation delimiter">,</span> <span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="variable">platform</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">unloadBuffers</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">model_weights</span><span class="punctuation bracket">)</span><span class="error">;</span>  <span class="comment">// for good practice</span>

<span class="comment">// Wait for compilation to finish</span>
<span class="type qualifier">const</span> <span class="variable">compiled</span> = <span class="operator">try</span> <span class="variable">compilation</span><span class="punctuation delimiter">.</span><span class="function">await_</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<p>Compiling is happening in the background via the <code>async_</code> function. We call <code>async_</code> with the <code>zml.compileModel</code> function and its arguments separately. The arguments themselves are basically the shapes of the weights in the BufferStore, the <code>.forward</code> function name in order to compile <code>Layer.forward</code>, the shape of the input tensor(s), and the platform for which to compile (we used auto platform).</p><h3 id="creating-the-executable-model">Creating the Executable Model</h3><p>Now that we have compiled the module utilizing the shapes, we turn it into an executable.</p><pre><code class="zig"><span class="comment">// pass the model weights to the compiled module to create an executable module</span>
<span class="type qualifier">var</span> <span class="variable">executable</span> = <span class="operator">try</span> <span class="variable">compiled</span><span class="punctuation delimiter">.</span><span class="function">prepare</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="variable">model_weights</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">executable</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<h3 id="calling---running-the-model">Calling / running the Model</h3><p>The executable can now be invoked with an input of our choice.</p><p>To create the <code>input</code>, we directly use <code>zml.Buffer</code> by calling <code>zml.Buffer.fromArray()</code>. It's important to note that <code>Buffer</code>s reside in <em>accelerator</em> (or <em>device</em>) memory, which is precisely where the input needs to be for the executable to process it on the device.</p><p>For clarity, let's recap the distinction: <code>HostBuffer</code>s are located in standard <em>host</em> memory, which is accessible by the CPU. When we initialized the weights, we used <code>HostBuffers</code> to set up the <code>BufferStore</code>. This is because the <code>BufferStore</code> typically loads weights from disk into <code>HostBuffer</code>s, and then converts them into <code>Buffer</code>s when we call <code>loadBuffers()</code>.</p><p>However, for inputs, we bypass the <code>BufferStore</code> and create <code>Buffer</code>s directly in device memory.</p><pre><code class="zig"><span class="comment">// prepare an input buffer</span>
<span class="comment">// Here, we use zml.HostBuffer.fromSlice to show how you would create a HostBuffer </span>
<span class="comment">// with a specific shape from an array.</span>
<span class="comment">// For situations where e.g. you have an [4]f16 array but need a .{2, 2} input shape.</span>
<span class="type qualifier">var</span> <span class="variable">input</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">5.0</span><span class="punctuation delimiter">,</span> <span class="float">5.0</span><span class="punctuation delimiter">,</span> <span class="float">5.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">var</span> <span class="variable">input_buffer</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Buffer</span><span class="punctuation delimiter">.</span><span class="function">from</span><span class="punctuation bracket">(</span><span class="variable">platform</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromSlice</span><span class="punctuation bracket">(</span><span class="variable">input_shape</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">input_buffer</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>

<span class="comment">// call our executable module</span>
<span class="type qualifier">var</span> <span class="variable">result</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Buffer</span> = <span class="variable">executable</span><span class="punctuation delimiter">.</span><span class="function">call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">input_buffer</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">defer</span> <span class="variable">result</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="error">;</span>

<span class="comment">// fetch the result buffer to CPU memory</span>
<span class="type qualifier">const</span> <span class="variable">cpu_result</span> = <span class="operator">try</span> <span class="variable">result</span><span class="punctuation delimiter">.</span><span class="function">toHostAlloc</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span>
    <span class="string">&quot;\n\nThe result of {d} * {d} + {d} = {d}\n&quot;</span><span class="punctuation delimiter">,</span>
    <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="operator">&</span><span class="variable">weights</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">input</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">bias</span><span class="punctuation delimiter">,</span> <span class="variable">cpu_result</span><span class="punctuation delimiter">.</span><span class="function">items</span><span class="punctuation bracket">(</span><span class="type builtin">f16</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
<span class="punctuation bracket">)</span><span class="error">;</span>
</code></pre>
<p>Note that the result of a computation is usually residing in the memory of the computation device, so with <code>.toHostAlloc()</code> we bring it back to CPU memory in the form of a <code>HostBuffer</code>. After that, we can print it.</p><p>In order to print it, we need to tell the host buffer how to interpret the memory. We do that by calling <code>.items(f16)</code>, making it cast the memory to <code>f16</code> items.</p><p>And that's it! Now, let's have a look at building and actually running this example!</p><h2 id="building-it">Building it</h2><p>As mentioned already, ZML uses Bazel; so to build our model, we just need to create a simple <code>BUILD.bazel</code> file, next to the <code>main.zig</code> file, like this:</p><pre><code class="python"><span class="function">load</span>(<span class="string">&quot;@zml//bazel:zig.bzl&quot;</span>, <span class="string">&quot;zig_cc_binary&quot;</span>)

<span class="function">zig_cc_binary</span>(
    <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;simple_layer&quot;</span>,
    <span class="variable">main</span> <span class="operator">=</span> <span class="string">&quot;main.zig&quot;</span>,
    <span class="variable">deps</span> <span class="operator">=</span> [
        <span class="string">&quot;@zml//async&quot;</span>,
        <span class="string">&quot;@zml//zml&quot;</span>,
    ],
)
</code></pre>
<p>To produce an executable, we import <code>zig_cc_binary</code> from the zig rules, and pass it a name and the zig file we just wrote. The dependencies in <code>deps</code> are what's needed for a basic ZML executable and correlate with our imports at the top of the Zig file:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">zml</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;zml&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">asynk</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;async&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
</code></pre>
<h2 id="running-it">Running it</h2><p>With everything in place now, running the model is easy:</p><pre><code># run release (-c opt)
cd examples
bazel run -c opt //simple_layer

# compile and run debug version
bazel run //simple_layer
</code></pre><p>And voila! Here's the output:</p><pre><code>bazel run -c opt //simple_layer
INFO: Analyzed target //simple_layer:simple_layer (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //simple_layer:simple_layer up-to-date:
  bazel-bin/simple_layer/simple_layer
INFO: Elapsed time: 0.120s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Running command line: bazel-bin/simple_layer/simple_layer
info(pjrt): Loaded library: libpjrt_cpu.dylib
info(zml_module): Compiling main.Layer.forward with { Shape({3}, dtype=.f16) }

The result of { 2, 2, 2 } * { 5, 5, 5 } + { 1, 2, 3 } = { 11, 12, 13 }
</code></pre><hr><p>You can access the complete source code of this walkthrough here:</p><ul><li><a href="https://github.com/zml/zml/tree/master/examples/simple_layer/main.zig" target="_blank">main.zig</a></li><li><a href="https://github.com/zml/zml/tree/master/examples/simple_layer/BUILD.bazel" target="_blank">BUILD.bazel</a></li></ul><h2 id="the-complete-example">The complete example</h2><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">std</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;std&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">zml</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;zml&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="type qualifier">const</span> <span class="variable">asynk</span> = <span class="function builtin">@import</span><span class="punctuation bracket">(</span><span class="string">&quot;async&quot;</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

<span class="type qualifier">const</span> <span class="variable">async_</span> = <span class="variable">asynk</span><span class="punctuation delimiter">.</span><span class="field">async_</span><span class="punctuation delimiter">;</span>

<span class="comment">/// Model definition
</span><span class="type qualifier">const</span> <span class="variable">Layer</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">bias</span><span class="punctuation delimiter">:</span> <span class="operator">?</span><span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> = <span class="constant builtin">null</span><span class="punctuation delimiter">,</span>
    <span class="field">weight</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="parameter">x</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> <span class="punctuation bracket">{</span>
        <span class="type qualifier">var</span> <span class="variable">y</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">weight</span><span class="punctuation delimiter">.</span><span class="function">mul</span><span class="punctuation bracket">(</span><span class="variable">x</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="conditional">if</span> <span class="punctuation bracket">(</span><span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">bias</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">|bias|</span> <span class="punctuation bracket">{</span>
            <span class="variable">y</span> <span class="operator">=</span> <span class="variable">y</span><span class="punctuation delimiter">.</span><span class="function">add</span><span class="punctuation bracket">(</span><span class="variable">bias</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
        <span class="punctuation bracket">}</span>
        <span class="keyword return">return</span> <span class="variable">y</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">main</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">_</span> <span class="operator">=</span> <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">asynk</span><span class="punctuation delimiter">.</span><span class="field">AsyncThread</span><span class="punctuation delimiter">.</span><span class="function">main</span><span class="punctuation bracket">(</span><span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">,</span> <span class="variable">asyncMain</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>

<span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">asyncMain</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span> <span class="exception">!</span><span class="type builtin">void</span> <span class="punctuation bracket">{</span>
    <span class="comment">// Short lived allocations</span>
    <span class="type qualifier">var</span> <span class="variable">gpa</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="function">GeneralPurposeAllocator</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">_</span> <span class="operator">=</span> <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">allocator</span> = <span class="variable">gpa</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Arena allocator for BufferStore etc.</span>
    <span class="type qualifier">var</span> <span class="variable">arena_state</span> = <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">heap</span><span class="punctuation delimiter">.</span><span class="field">ArenaAllocator</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="variable">allocator</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">arena_state</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">arena</span> = <span class="variable">arena_state</span><span class="punctuation delimiter">.</span><span class="function">allocator</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Create ZML context</span>
    <span class="type qualifier">var</span> <span class="variable">context</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Context</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">context</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="type qualifier">const</span> <span class="variable">platform</span> = <span class="variable">context</span><span class="punctuation delimiter">.</span><span class="function">autoPlatform</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Our weights and bias to use</span>
    <span class="type qualifier">var</span> <span class="variable">weights</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">var</span> <span class="variable">bias</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">1.0</span><span class="punctuation delimiter">,</span> <span class="float">2.0</span><span class="punctuation delimiter">,</span> <span class="float">3.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">const</span> <span class="variable">input_shape</span> = <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Shape</span><span class="punctuation delimiter">.</span><span class="function">init</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="number">3</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable builtin">f16</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// We manually produce a BufferStore. You would not normally do that.</span>
    <span class="comment">// A BufferStore is usually created by loading model data from a file.</span>
    <span class="type qualifier">var</span> <span class="variable">buffers</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="field">BufferStore</span><span class="punctuation delimiter">.</span><span class="field">Buffers</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">buffers</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="string">&quot;weight&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromArray</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">weights</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="operator">try</span> <span class="variable">buffers</span><span class="punctuation delimiter">.</span><span class="function">put</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="string">&quot;bias&quot;</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromArray</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">bias</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// the actual BufferStore</span>
    <span class="type qualifier">const</span> <span class="variable">bs</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="field">BufferStore</span> = <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span>
        <span class="punctuation delimiter">.</span><span class="field">arena</span> = <span class="variable">arena_state</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="field">buffers</span> = <span class="variable">buffers</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>

    <span class="comment">// A clone of our model, consisting of shapes. We only need shapes for compiling.</span>
    <span class="comment">// We use the BufferStore to infer the shapes.</span>
    <span class="type qualifier">const</span> <span class="variable">model_shapes</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">populateModel</span><span class="punctuation bracket">(</span><span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">bs</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Start compiling. This uses the inferred shapes from the BufferStore.</span>
    <span class="comment">// The shape of the input tensor, we have to pass in manually.</span>
    <span class="type qualifier">var</span> <span class="variable">compilation</span> = <span class="operator">try</span> <span class="variable">async_</span><span class="punctuation bracket">(</span><span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">compileModel</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="variable">allocator</span><span class="punctuation delimiter">,</span> <span class="variable">model_shapes</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="variable builtin">forward</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">input_shape</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">platform</span> <span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Produce a bufferized weights struct from the fake BufferStore.</span>
    <span class="comment">// This is like the inferred shapes, but with actual values.</span>
    <span class="comment">// We will need to send those to the computation device later.</span>
    <span class="type qualifier">const</span> <span class="variable">model_weights</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">loadBuffers</span><span class="punctuation bracket">(</span><span class="variable">Layer</span><span class="punctuation delimiter">,</span> <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span> <span class="variable">bs</span><span class="punctuation delimiter">,</span> <span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="variable">platform</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">aio</span><span class="punctuation delimiter">.</span><span class="function">unloadBuffers</span><span class="punctuation bracket">(</span><span class="operator">&</span><span class="variable">model_weights</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// Wait for compilation to finish</span>
    <span class="type qualifier">const</span> <span class="variable">compiled</span> = <span class="operator">try</span> <span class="variable">compilation</span><span class="punctuation delimiter">.</span><span class="function">await_</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// pass the model weights to the compiled module to create an executable module</span>
    <span class="type qualifier">var</span> <span class="variable">executable</span> = <span class="operator">try</span> <span class="variable">compiled</span><span class="punctuation delimiter">.</span><span class="function">prepare</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation delimiter">,</span> <span class="variable">model_weights</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">executable</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// prepare an input buffer</span>
    <span class="comment">// Here, we use zml.HostBuffer.fromSlice to show how you would create a HostBuffer</span>
    <span class="comment">// with a specific shape from an array.</span>
    <span class="comment">// For situations where e.g. you have an [4]f16 array but need a .{2, 2} input shape.</span>
    <span class="type qualifier">var</span> <span class="variable">input</span> = <span class="punctuation bracket">[</span><span class="number">3</span><span class="punctuation bracket">]</span><span class="type builtin">f16</span><span class="punctuation bracket">{</span> <span class="float">5.0</span><span class="punctuation delimiter">,</span> <span class="float">5.0</span><span class="punctuation delimiter">,</span> <span class="float">5.0</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">;</span>
    <span class="type qualifier">var</span> <span class="variable">input_buffer</span> = <span class="operator">try</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Buffer</span><span class="punctuation delimiter">.</span><span class="function">from</span><span class="punctuation bracket">(</span><span class="variable">platform</span><span class="punctuation delimiter">,</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">HostBuffer</span><span class="punctuation delimiter">.</span><span class="function">fromSlice</span><span class="punctuation bracket">(</span><span class="variable">input_shape</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">input_buffer</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// call our executable module</span>
    <span class="type qualifier">var</span> <span class="variable">result</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Buffer</span> = <span class="variable">executable</span><span class="punctuation delimiter">.</span><span class="function">call</span><span class="punctuation bracket">(</span><span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span><span class="variable">input_buffer</span><span class="punctuation bracket">}</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="keyword">defer</span> <span class="variable">result</span><span class="punctuation delimiter">.</span><span class="function">deinit</span><span class="punctuation bracket">(</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>

    <span class="comment">// fetch the result to CPU memory</span>
    <span class="type qualifier">const</span> <span class="variable">cpu_result</span> = <span class="operator">try</span> <span class="variable">result</span><span class="punctuation delimiter">.</span><span class="function">toHostAlloc</span><span class="punctuation bracket">(</span><span class="variable">arena</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
    <span class="variable">std</span><span class="punctuation delimiter">.</span><span class="field">debug</span><span class="punctuation delimiter">.</span><span class="function">print</span><span class="punctuation bracket">(</span>
        <span class="string">&quot;\n\nThe result of {d} * {d} + {d} = {d}\n&quot;</span><span class="punctuation delimiter">,</span>
        <span class="punctuation delimiter">.</span><span class="punctuation bracket">{</span> <span class="operator">&</span><span class="variable">weights</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">input</span><span class="punctuation delimiter">,</span> <span class="operator">&</span><span class="variable">bias</span><span class="punctuation delimiter">,</span> <span class="variable">cpu_result</span><span class="punctuation delimiter">.</span><span class="function">items</span><span class="punctuation bracket">(</span><span class="type builtin">f16</span><span class="punctuation bracket">)</span> <span class="punctuation bracket">}</span><span class="punctuation delimiter">,</span>
    <span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
<span class="punctuation bracket">}</span>
</code></pre>
<h2 id="where-to-go-from-here">Where to go from here</h2><ul><li><a href="/howtos/add_weights/">Add some weights files to your model</a></li><li><a href="/tutorials/getting_started/">Run the model on GPU</a></li><li><a href="/howtos/deploy_on_server/">Deploy the model on a server</a></li><li><a href="/howtos/dockerize_models/">Dockerize this model</a></li><li><a href="/learn/concepts/">Learn more about ZML concepts</a></li><li><a href="/howtos/howto_torch2zml/">Find out how to best port PyTorch models</a></li></ul></div>
</div>
    </main>


    <footer>
        <!-- OPTION 1: with Zine -->
        <b>&copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> </b> — <i>made with <a href="https://zine-ssg.io" target="_blank">Zine</a></i>

        <!-- OPTION 2: ZML only -->
        <!-- &copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> -->
    </footer>
  </body>
</html>
