<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="ZML - A high performance AI inference stack. Built for production. @ziglang / @openxla / MLIR / @bazelbuild">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@zml_ai">
    <meta name="twitter:author" content="@zml_ai">
    <meta name="twitter:description" content="ZML - A high performance AI inference stack. Built for production. @ziglang / @openxla / MLIR / @bazelbuild">
    <meta name="twitter:image" content="https://zml.ai/zml_nolight.svg">
    <meta name="twitter:title" content="ZML Concepts | ZML">
    <meta property="og:title" content="ZML Concepts">
    <meta property="og:type" content="website">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      ZML Concepts
      - ZML
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    <link rel="icon" href="/zml.no_light.svg">
    
  </head>
  <body>
    <a id="logo" href="/"></a>
    <nav id="menu">
      <!-- burger menu -->
      <button id="burger-menu" aria-label="Toggle Menu">&#9776;</button> <!-- Burger menu icon -->

      <a href="/">Home</a>
      •
      <a href="/tutorials/getting_started/">Quickstart</a>
      •
      <a href="/tutorials/write_first_model/">First Steps</a>
      <!-- • -->
      <!-- <a href="$site.page('concepts').link()">Concepts</a> -->
      <!-- • -->
      <!-- <a href="$site.page('using_zml_in_own_projects').link()">Using it in projects</a> -->
      •
      <a href="/misc/zml_api/">API Docs</a>
      •
      <a href="https://github.com/zml/zml" target="_blank">Code</a>
      •
      <a href="https://discord.gg/6y72SN2E7H" target="_blank">Discord</a>


    </nav>
    <!-- <hr style="width:min(600px, 100vw); border-color:#0798b3; color: white; border-top:1px;"> -->
    <aside id="sidebar" class="sidebar">
        <!-- <h3>Docs</h3> -->
        <a href="/tutorials/"><h5>Tutorials</h5></a>
        <div class="linkbox">
            <div><a href="/tutorials/getting_started/">Getting Started with ZML</a></div>
        
            <div><a href="/tutorials/write_first_model/">Writing your first model</a></div>
        
            <div><a href="/tutorials/working_with_tensors/">Simplifying Dimension Handling with Tagged Tensors</a></div>
        </div>
        <a href="/howtos/"><h5>How-Tos</h5></a>
        <div class="linkbox">
            <div><a href="/howtos/huggingface_access_token/">Huggingface Token Authentication</a></div>
        
            <div><a href="/howtos/dockerize_models/">Dockerize a Model</a></div>
        
            <div><a href="/howtos/deploy_on_server/">Deploying Models on a Server</a></div>
        
            <div><a href="/howtos/howto_torch2zml/">How to port Pytorch models to ZML ?</a></div>
        
            <div><a href="/howtos/add_weights/">Adding Weights Files</a></div>
        </div>
        <a href="/tutorials/"><h5>Learn more</h5></a>
        <div class="linkbox">
            <div><a href="/learn/concepts/">ZML Concepts</a></div>
        </div>
        <a href="/tutorials/"><h5>Misc</h5></a>
        <div class="linkbox">
            <div><a href="/misc/style_guide/">ZML Style Guide</a></div>
        
            <div><a href="/misc/zml_api/">API Docs</a></div>
        </div>
    </aside>

    <main>
        <div id="content">
  <style>
    h1 {
       margin-top: 0;
     }

		#docs h2, #docs h3 {
			text-align: left;
		}

		#docs h3 {
			font-size: 1.2rem;
		}

		#docs h3::before {
      content: "##";
      font-size: 1rem;
      padding-right: 4px;
      margin-bottom: 0;
    }

    #docs h2 {
      font-size: 1.5rem;
      border-bottom: 1px dashed #aaa;
    }

    #docs h2::before {
      content: "#";
      font-size: 1rem;
      padding-right: 4px;
    }

    #docs h4 {
      font-size: 1rem;
    }

    table {
      font-size: 0.9em;
    }
    table th {
      font-size: 1em;
    }
    table td {
      white-space: nowrap;
    }
  </style>
  <h3 class="centered"></h3>
  <script>
    // Find all short <code> elements in the document, and replace them with links to our docs, or pytorch docs.
    document.addEventListener('DOMContentLoaded', function() {
      const codeElements = document.querySelectorAll('code');

      codeElements.forEach(function(codeElement) {
          const codeContent = codeElement.textContent;
          if (codeContent.includes(' ')) return;

          if (codeContent.startsWith('zml.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "/misc/zml_api/#" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          } else if (codeContent.startsWith('torch.')) {
            const linkElement = document.createElement('a');
            linkElement.href = "https://pytorch.org/docs/stable/generated/" + codeContent;
            linkElement.textContent = codeContent;
            codeElement.replaceWith(linkElement);
          }
      });
  });
  </script>
  <!-- <h1 :text="$page.title"></h1> -->
  <div id="docs"><h1 id="zml-concepts">ZML Concepts</h1><h2 id="model-lifecycle">Model lifecycle</h2><p>ZML is an inference stack that helps running Machine Learning (ML) models, and particulary Neural Networks (NN).</p><p>The lifecycle of a model is implemented in the following steps:</p><ol><li><p>Open the model file and read the shapes of the weights, but leave the weights on the disk.</p></li><li><p>Using the loaded shapes and optional metadata, instantiate a model struct with <code>Tensor</code>s, representing the shape and layout of each layer of the NN.</p></li><li><p>Compile the model struct and it's <code>forward</code> function into an accelerator specific executable. The <code>forward</code> function describes the mathematical operations corresponding to the model inference.</p></li><li><p>Load the model weights from disk, onto the accelerator memory.</p></li><li><p>Bind the model weights to the executable.</p></li><li><p>Load some user inputs, and copy them to the accelerator.</p></li><li><p>Call the executable on the user inputs.</p></li><li><p>Fetch the returned model output from accelerator into host memory, and finally present it to the user.</p></li><li><p>When all user inputs have been processed, free the executable resources and the associated weights.</p></li></ol><p><strong>Some details:</strong></p><p>Note that the compilation and weight loading steps are both bottlenecks to your model startup time, but they can be done in parallel. <strong>ZML provides asynchronous primitives</strong> to make that easy.</p><p>The <strong>compilation can be cached</strong> across runs, and if you're always using the same model architecture with the same shapes, it's possible to by-pass it entirely.</p><p>The accelerator is typically a GPU, but can be another chip, or even the CPU itself, churning vector instructions.</p><h2 id="tensor-bros">Tensor Bros.</h2><p>In ZML, we leverage Zig's static type system to differentiate between a few concepts, hence we not only have a <code>Tensor</code> to work with, like other ML frameworks, but also <code>Buffer</code>, <code>HostBuffer</code>, and <code>Shape</code>.</p><p>Let's explain all that.</p><ul><li><p><code>Shape</code>: <em>describes</em> a multi-dimension array.</p><ul><li><code>Shape.init(.{16}, .f32)</code> represents a vector of 16 floats of 32 bits precision.</li><li><code>Shape.init(.{512, 1024}, .f16)</code> represents a matrix of <code>512*1024</code> floats of 16 bits precision, i.e. a <code>[512][1024]f16</code> array.</li></ul><p>A <code>Shape</code> is only <strong>metadata</strong>, it doesn't point to or own any memory. The <code>Shape</code> struct can also represent a regular number, aka a scalar: <code>Shape.init(.{}, .i32)</code> represents a 32-bit signed integer.</p></li><li><p><code>HostBuffer</code>: <em>is</em> a multi-dimensional array, whose memory is allocated <strong>on the CPU</strong>.</p><ul><li>points to the slice of memory containing the array</li><li>typically owns the underlying memory - but has a flag to remember when it doesn't.</li></ul></li><li><p><code>Buffer</code>: <em>is</em> a multi-dimension array, whose memory is allocated <strong>on an accelerator</strong>.</p><ul><li>contains a handle that the ZML runtime can use to convert it into a physical address, but there is no guarantee this address is visible from the CPU.</li><li>can be created by loading weights from disk directly to the device via <code>zml.aio.loadBuffers</code></li><li>can be created by calling <code>HostBuffer.toDevice(accelerator)</code>.</li></ul></li><li><p><code>Tensor</code>: is a mathematical object representing an intermediary result of a computation.</p><ul><li>is basically a <code>Shape</code> with an attached MLIR value representing the mathematical operation that produced this <code>Tensor</code>.</li></ul></li></ul><h2 id="the-model-struct">The model struct</h2><p>The model struct is the Zig code that describes your Neural Network (NN). Let's look a the following model architecture:</p><p><figure><img src="https://zml.ai/docs-assets/perceptron.png">
<figcaption>Multilayer perceptrons</figcaption></figure></p><p>This is how we can describe it in a Zig struct:</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">Model</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">input_layer</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>
    <span class="field">output_layer</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Model</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">const</span> <span class="variable">hidden</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">input_layer</span><span class="punctuation delimiter">.</span><span class="function">matmul</span><span class="punctuation bracket">(</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="type qualifier">const</span> <span class="variable">output</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">output_layer</span><span class="punctuation delimiter">.</span><span class="function">matmul</span><span class="punctuation bracket">(</span><span class="variable">hidden</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="keyword return">return</span> <span class="variable">output</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter"></span>
</code></pre>
<p>NNs are generally seen as a composition of smaller NNs, which are split into layers. ZML makes it easy to mirror this structure in your code.</p><pre><code class="zig"><span class="type qualifier">const</span> <span class="variable">Model</span> = <span class="keyword">struct</span> <span class="punctuation bracket">{</span>
    <span class="field">input_layer</span><span class="punctuation delimiter">:</span> <span class="variable">MyOtherLayer</span><span class="punctuation delimiter">,</span>
    <span class="field">output_layer</span><span class="punctuation delimiter">:</span> <span class="variable">MyLastLayer</span><span class="punctuation delimiter">,</span>

    <span class="attribute">pub</span> <span class="keyword function">fn</span> <span class="function">forward</span><span class="punctuation bracket">(</span><span class="parameter">self</span><span class="punctuation delimiter">:</span> <span class="variable">Model</span><span class="punctuation delimiter">,</span> <span class="parameter">input</span><span class="punctuation delimiter">:</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span><span class="punctuation bracket">)</span> <span class="variable">zml</span><span class="punctuation delimiter">.</span><span class="field">Tensor</span> <span class="punctuation bracket">{</span>
      <span class="type qualifier">const</span> <span class="variable">hidden</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">input_layer</span><span class="punctuation delimiter">.</span><span class="function">forward</span><span class="punctuation bracket">(</span><span class="variable">input</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="type qualifier">const</span> <span class="variable">output</span> = <span class="variable">self</span><span class="punctuation delimiter">.</span><span class="field">output_layer</span><span class="punctuation delimiter">.</span><span class="function">forward</span><span class="punctuation bracket">(</span><span class="variable">hidden</span><span class="punctuation bracket">)</span><span class="punctuation delimiter">;</span>
      <span class="keyword return">return</span> <span class="variable">output</span><span class="punctuation delimiter">;</span>
    <span class="punctuation bracket">}</span>
<span class="punctuation bracket">}</span><span class="punctuation delimiter"></span>
</code></pre>
<p><code>zml.nn</code> module provides a number of well-known layers to more easily bootstrap models.</p><p>Since the <code>Model</code> struct contains <code>Tensor</code>s, it is only ever useful during the compilation stage, but not during inference. If we want to represent the model with actual <code>Buffer</code>s, we can use the <code>zml.Bufferize(Model)</code>, which is a mirror struct of <code>Model</code> but with a <code>Buffer</code> replacing every <code>Tensor</code>.</p><h2 id="strong-type-checking">Strong type checking</h2><p>Let's look at the model life cycle again, but this time annotated with the corresponding types.</p><ol><li><p>Open the model file and read the shapes of the weights -> <code>zml.HostBuffer</code> (using memory mapping, no actual copies happen yet)</p></li><li><p>Instantiate a model struct -> <code>Model</code> struct (with <code>zml.Tensor</code> inside)</p></li><li><p>Compile the model struct and its <code>forward</code> function into an executable. <code>foward</code> is a <code>Tensor -&gt; Tensor</code> function, executable is a <code>zml.Exe(Model.forward)</code></p></li><li><p>Load the model weights from disk, onto accelerator memory -> <code>zml.Bufferized(Model)</code> struct (with <code>zml.Buffer</code> inside)</p></li><li><p>Bind the model weights to the executable <code>zml.ExeWithWeight(Model.forward)</code></p></li><li><p>Load some user inputs (custom struct), encode them into arrays of numbers (<code>zml.HostBuffer</code>), and copy them to the accelerator (<code>zml.Buffer</code>).</p></li><li><p>Call the executable on the user inputs. <code>module.call</code> accepts <code>zml.Buffer</code> arguments and returns <code>zml.Buffer</code></p></li><li><p>Return the model output (<code>zml.Buffer</code>) to the host (<code>zml.HostBuffer</code>), decode it (custom struct) and finally return to the user.</p></li></ol></div>
</div>
    </main>


    <footer>
        <!-- OPTION 1: with Zine -->
        <b>&copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> </b> — <i>made with <a href="https://zine-ssg.io" target="_blank">Zine</a></i>

        <!-- OPTION 2: ZML only -->
        <!-- &copy; in 2024 by <a href="https://zml.ai" target="_blank">ZML.ai</a> -->
    </footer>

  <!-- burger menu script -->
  <script>
      document.getElementById('burger-menu').addEventListener('click', function() {
        const sidebar = document.getElementById('sidebar');
        const logo = document.getElementById('logo');
        const body = document.body;

        // Toggle the 'active' class on sidebar and logo to show/hide them
        sidebar.classList.toggle('active');
        logo.classList.toggle('active');
        
        // Toggle the 'show-sidebar' class on the body to adjust the grid layout
        body.classList.toggle('show-sidebar');
      });
</script>
  </body>
</html>
